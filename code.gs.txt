const SPREADSHEET_ID = 'rRPiIMSWTcJOcWJX95Qtgag'; // <--- IMPORTANT: Replace with your actual Spreadsheet ID
const SHEET_NAME = 'dataset'; // <--- IMPORTANT: Replace with your actual Sheet Name containing the data

// Define column indices for clarity (0-indexed) based on your provided headers
const COLUMNS = {
  LEARNER_CODE: 0,            // Learner Code
  AGE: 1,                     // Age
  GENDER: 2,                  // Gender
  LEARNER_DISTRICT: 3,        // LearnerDistrict
  MOTHER_TONGUE: 4,           // MotherToungue
  MARITAL_STATUS: 5,          // MaritalStatus
  QUALIFICATION: 6,           // Qualification
  CATEGORY_NAME: 7,           // CategoryName
  BATCH_EXAM_EVENT: 8,        // Batch (Contains "January 2024 Exam Event")
  CENTER_NAME: 9,             // Center Name
  CENTER_CODE: 10,            // Center Code
  RLC_REGION: 11,             // RLC Region
  RLC_NAME: 12,               // RLC Name
  LLC_REGION: 13,             // LLC Region
  LLC_NAME: 14,               // LLC Name
  MODE_NAME: 15,              // ModeName
  MEDIUM: 16,                 // Medium
  BATCH_DURATION: 17,         // BatchDuration
  COURSE_MODE: 18,            // CourseMode
  LEARNING_MODE: 19,            // LearningMode
  PAYMENT_STATUS: 20,         // PaymentStatus
  COMPLETED_SESSION_COUNT: 21,// Completed Session Count
  INTERNAL_MARKS_MSBTE: 22,   // Internal Marks (MSBTE)
  INTERNAL_SCORE_POINTS: 23,  // Internal Score (Points)
  PAYMENT_MODE: 24,           // Payment Mode
  EXAM_DATE: 25               // <--- Assuming an EXAM_DATE column for precise deadlines, adjust if not present
};

/**
 * Serves the HTML content for the web app.
 * This is the entry point for the standalone web app URL.
 */
function doGet() {
  return HtmlService.createTemplateFromFile('Dashboard')
      .evaluate()
      .setTitle('ALC-BDP Admissions Dashboard');
}

/**
 * Extracts Year and Month from the 'Batch (Exam Event)' string.
 * Example: "January 2024 Exam Event" -> { year: "2024", monthName: "January", monthNum: "01" }
 * @param {string} batchString
 * @returns {object} An object containing year, monthName, and monthNum.
 */
function parseBatchDate(batchString) {
  const match = batchString.match(/(\w+)\s+(\d{4})\s+Exam Event/i);
  if (match) {
    const monthName = match[1];
    const year = match[2];
    const monthNum = new Date(Date.parse(monthName +" 1, 2000")).getMonth() + 1; // Converts month name to 1-12
    return {
      year: year,
      monthName: monthName,
      monthNum: monthNum.toString().padStart(2, '0') // "01", "02", etc.
    };
  }
  return { year: '', monthName: '', monthNum: '' };
}


/**
 * Fetches unique values for filters from the raw data.
 * This function is called once when the dashboard loads to populate the dropdowns.
 */
function getUniqueFilterValues() {
  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAME);
  const data = sheet.getDataRange().getValues();
  if (data.length <= 1) { // Only header row or no data
    return {
      years: [], examEvents: [], rlcRegions: [],
      learnerDistricts: [], genders: [], qualifications: []
    };
  }

  // Skip header row
  const values = data.slice(1);

  const years = new Set();
  const examEvents = new Set();
  const rlcRegions = new Set();
  const learnerDistricts = new Set();
  const genders = new Set();
  const qualifications = new Set();

  values.forEach(row => {
    // Extract year and exam event from BATCH_EXAM_EVENT column
    const batchString = row[COLUMNS.BATCH_EXAM_EVENT] ? row[COLUMNS.BATCH_EXAM_EVENT].toString() : '';
    const { year } = parseBatchDate(batchString);
    if (year) years.add(year);
    if (batchString) examEvents.add(batchString); // Use the full batch string for exam event filter

    if (row[COLUMNS.RLC_REGION]) rlcRegions.add(row[COLUMNS.RLC_REGION].toString());
    if (row[COLUMNS.LEARNER_DISTRICT]) learnerDistricts.add(row[COLUMNS.LEARNER_DISTRICT].toString());
    if (row[COLUMNS.GENDER]) genders.add(row[COLUMNS.GENDER].toString());
    if (row[COLUMNS.QUALIFICATION]) qualifications.add(row[COLUMNS.QUALIFICATION].toString());
  });

  return {
    years: Array.from(years).sort(),
    examEvents: Array.from(examEvents).sort(),
    rlcRegions: Array.from(rlcRegions).sort(),
    learnerDistricts: Array.from(learnerDistricts).sort(),
    genders: Array.from(genders).sort(),
    qualifications: Array.from(qualifications).sort()
  };
}


/**
 * Fetches and processes data for the dashboard based on selected filters.
 * This is the main data retrieval function called by the client-side JS.
 * @param {Object} filters - An object containing the current filter selections.
 * @returns {Object} An object containing kpis, tableData, chartData, and recommendations.
 */
function getDataForDashboard(filters) {
  // Ensure filters is an object even if undefined is passed from client.
  filters = filters || {}; 

  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAME);
  const rawData = sheet.getDataRange().getValues();

  if (rawData.length <= 1) {
    // Return empty state if no data
    return {
      kpis: {
        totalAdmissions: 0, completionRate: '0%', avgInternalMarks: 'N/A',
        avgInternalScore: 'N/A', overallTarget: 0, predictedAdmissions: 'N/A', onTrackWarning: false
      },
      tableData: [],
      chartData: {
        admissionsTrend: { series: [], categories: [] },
        admissionsByRlcRegion: [], genderDistribution: [], admissionsByQualification: [],
        lowCompletionCenters: [],
        examEventPrediction: { series: [], suggestedTarget: 0, manualTarget: 0, displayedTarget: 0, targetAlert: '' },
        admissionsHeatmap: { series: [], geoCategories: [], demoCategories: [] }, // Updated structure
        alcLlcBubbleChart: []
      },
      recommendations: ["No data available. Please check your spreadsheet and column mappings."]
    };
  }

  // Ensure filter values are always strings and provide 'All' as default if undefined
  const effectiveFilters = {
    year: filters.year ? String(filters.year) : 'All',
    examEvent: filters.examEvent ? String(filters.examEvent) : 'All',
    rlcRegion: filters.rlcRegion ? String(filters.rlcRegion) : 'All',
    learnerDistrict: filters.learnerDistrict ? String(filters.learnerDistrict) : 'All',
    gender: filters.gender ? String(filters.gender) : 'All',
    qualification: filters.qualification ? String(filters.qualification) : 'All',
    overallTarget: parseInt(filters.overallTarget) || 0,
    manualTarget: parseInt(filters.manualTarget) || 0,
    selectedExamEvent: filters.selectedExamEvent ? String(filters.selectedExamEvent) : '',
    examEventEndDate: filters.examEventEndDate ? String(filters.examEventEndDate) : ''
  };

  let filteredData = rawData.slice(1); // Exclude header row

  // Apply filters for non-year specific data
  filteredData = filteredData.filter(row => {
    const batchString = row[COLUMNS.BATCH_EXAM_EVENT] ? row[COLUMNS.BATCH_EXAM_EVENT].toString() : '';
    const rowExamEvent = batchString;
    const rowRlcRegion = row[COLUMNS.RLC_REGION] ? row[COLUMNS.RLC_REGION].toString() : '';
    const rowLearnerDistrict = row[COLUMNS.LEARNER_DISTRICT] ? row[COLUMNS.LEARNER_DISTRICT].toString() : '';
    const rowGender = row[COLUMNS.GENDER] ? row[COLUMNS.GENDER].toString() : '';
    const rowQualification = row[COLUMNS.QUALIFICATION] ? row[COLUMNS.QUALIFICATION].toString() : '';

    return (effectiveFilters.examEvent === 'All' || rowExamEvent === effectiveFilters.examEvent) &&
           (effectiveFilters.rlcRegion === 'All' || rowRlcRegion === effectiveFilters.rlcRegion) &&
           (effectiveFilters.learnerDistrict === 'All' || rowLearnerDistrict === effectiveFilters.learnerDistrict) &&
           (effectiveFilters.gender === 'All' || rowGender === effectiveFilters.gender) &&
           (effectiveFilters.qualification === 'All' || rowQualification === effectiveFilters.qualification);
  });

  // --- Initialize Aggregation Variables ---
  let totalAdmissions = 0;
  let completedAdmissions = 0;
  let totalInternalMarks = 0;
  let internalMarksCount = 0;
  let totalInternalScore = 0;
  let internalScoreCount = 0;

  const uniqueLearnerCodes = new Set();
  
  const admissionsByMonthYearAllYears = new Map(); // Key: "YYYY-MM", Value: Set<unique_learner_code>
  const rlcRegionAdmissionsMap = new Map(); // Key: "RLC_Region", Value: Set<unique_learner_code>
  const genderDistributionMap = new Map(); // Key: "Gender", Value: Set<unique_learner_code>
  const qualificationAdmissionsMap = new Map(); // Key: "Qualification", Value: Set<unique_learner_code>
  const centerAggregates = new Map(); // Key: Center Code, Value: { totalLearners: Set, completedLearners: Set, ... }
  const heatmapAggregationMap = new Map(); // Key: Geographic Level, Value: Map<Demographic Level, Set<unique_learner_code>>
  const examEventHistoricalData = new Map(); // Key: year, Value: Set<learner_code> for selectedExamEvent
  const admissionsByLearnerDistrict = new Map(); // Key: District, Value: Set<learner_code>


  // --- Process Filtered Data ---
  filteredData.forEach(row => {
    const learnerCode = row[COLUMNS.LEARNER_CODE];
    if (!learnerCode) return;

    const batchString = row[COLUMNS.BATCH_EXAM_EVENT] ? row[COLUMNS.BATCH_EXAM_EVENT].toString() : '';
    const { year: rowYear, monthNum } = parseBatchDate(batchString);

    const geographicLevel = row[COLUMNS.RLC_REGION] ? row[COLUMNS.RLC_REGION].toString() : 'Unknown Region'; 
    const demographicLevel = row[COLUMNS.QUALIFICATION] ? row[COLUMNS.QUALIFICATION].toString() : 'Unknown Qualification'; 

    // This `if` block applies the main year filter (effectiveFilters.year) for KPIs, table, and most charts.
    if (effectiveFilters.year === 'All' || rowYear === effectiveFilters.year) {
      uniqueLearnerCodes.add(learnerCode);

      const completedSessionCount = parseInt(row[COLUMNS.COMPLETED_SESSION_COUNT]);
      const isCompleted = completedSessionCount > 0 && !isNaN(completedSessionCount); 
      if (isCompleted) { completedAdmissions++; }

      const internalMarks = parseFloat(row[COLUMNS.INTERNAL_MARKS_MSBTE]);
      if (!isNaN(internalMarks)) { totalInternalMarks += internalMarks; internalMarksCount++; }
      const internalScore = parseFloat(row[COLUMNS.INTERNAL_SCORE_POINTS]);
      if (!isNaN(internalScore)) { totalInternalScore += internalScore; internalScoreCount++; }

      const rlcRegion = row[COLUMNS.RLC_REGION];
      if (rlcRegion) {
        if (!rlcRegionAdmissionsMap.has(rlcRegion)) { rlcRegionAdmissionsMap.set(rlcRegion, new Set()); }
        rlcRegionAdmissionsMap.get(rlcRegion).add(learnerCode);
      }

      const gender = row[COLUMNS.GENDER];
      if (gender) {
        if (!genderDistributionMap.has(gender)) { genderDistributionMap.set(gender, new Set()); }
        genderDistributionMap.get(gender).add(learnerCode);
      }

      const qualification = row[COLUMNS.QUALIFICATION];
      if (qualification) {
        if (!qualificationAdmissionsMap.has(qualification)) { qualificationAdmissionsMap.set(qualification, new Set()); }
        qualificationAdmissionsMap.get(qualification).add(learnerCode);
      }

      const centerCode = row[COLUMNS.CENTER_CODE];
      const centerName = row[COLUMNS.CENTER_NAME]; 
      if (centerCode && centerName) {
        if (!centerAggregates.has(centerCode)) {
          centerAggregates.set(centerCode, {
            centerName: centerName, totalLearners: new Set(), completedLearners: new Set(),
            totalMarks: 0, marksCount: 0, totalScore: 0, scoreCount: 0,
            genderMix: new Map(), paymentMix: new Map(), totalAge: 0, ageCount: 0
          });
        }
        const center = centerAggregates.get(centerCode);
        center.totalLearners.add(learnerCode);
        if (isCompleted) { center.completedLearners.add(learnerCode); }
        if (!isNaN(internalMarks)) { center.totalMarks += internalMarks; center.marksCount++; }
        if (!isNaN(internalScore)) { center.totalScore += internalScore; center.scoreCount++; }
        if (gender) { center.genderMix.set(gender, (center.genderMix.get(gender) || 0) + 1); }
        const paymentStatus = row[COLUMNS.PAYMENT_STATUS];
        if (paymentStatus) { center.paymentMix.set(paymentStatus, (center.paymentMix.get(paymentStatus) || 0) + 1); }
        const learnerAge = parseInt(row[COLUMNS.AGE]);
        if (!isNaN(learnerAge)) { center.totalAge = (center.totalAge || 0) + learnerAge; center.ageCount = (center.ageCount || 1) + 1; }
      }

      const learnerDistrict = row[COLUMNS.LEARNER_DISTRICT];
      if (learnerDistrict) {
        if (!admissionsByLearnerDistrict.has(learnerDistrict)) { admissionsByLearnerDistrict.set(learnerDistrict, new Set()); }
        admissionsByLearnerDistrict.get(learnerDistrict).add(learnerCode);
      }

      // Heatmap Data (aggregates for the current `filteredData` which respects year/other filters)
      if (!heatmapAggregationMap.has(geographicLevel)) { heatmapAggregationMap.set(geographicLevel, new Map()); }
      const demographicMap = heatmapAggregationMap.get(geographicLevel);
      if (!demographicMap.has(demographicLevel)) { demographicMap.set(demographicLevel, new Set()); }
      demographicMap.get(demographicLevel).add(learnerCode);

    } // End of year-filtered data for KPIs and tables/most charts

    // Always collect data for Admissions Trend by Month, regardless of the year filter,
    // so we have historical data for comparison.
    if (rowYear && monthNum) {
      const monthYearKey = `${rowYear}-${monthNum}`;
      if (!admissionsByMonthYearAllYears.has(monthYearKey)) { admissionsByMonthYearAllYears.set(monthYearKey, new Set()); }
      admissionsByMonthYearAllYears.get(monthYearKey).add(learnerCode);
    }

    // Exam Event Prediction (collect data for selectedExamEvent across years)
    if (effectiveFilters.selectedExamEvent && batchString.includes(effectiveFilters.selectedExamEvent)) {
      if (!examEventHistoricalData.has(rowYear)) { examEventHistoricalData.set(rowYear, new Set()); }
      examEventHistoricalData.get(rowYear).add(learnerCode);
    }
  });

  totalAdmissions = uniqueLearnerCodes.size;

  // --- KPI: Overall Admissions vs Target (with Prediction) ---
  const today = new Date();
  let deadline = null;
  
  if (effectiveFilters.examEventEndDate) {
    deadline = new Date(effectiveFilters.examEventEndDate);
  } else if (effectiveFilters.year !== 'All' && effectiveFilters.year) {
    deadline = new Date(parseInt(effectiveFilters.year), 11, 31);
  } else {
    deadline = new Date(today.getFullYear(), 11, 31);
  }

  let daysElapsed = 0;
  let totalDays = 0;
  let predictedAdmissions = 'N/A';
  let onTrackWarning = false;

  const relevantStartDate = new Date(deadline.getFullYear(), 0, 1);

  if (deadline && !isNaN(deadline.getTime())) {
    daysElapsed = Math.ceil((today.getTime() - relevantStartDate.getTime()) / (1000 * 60 * 60 * 24));
    totalDays = Math.ceil((deadline.getTime() - relevantStartDate.getTime()) / (1000 * 60 * 60 * 24));

    if (daysElapsed <= 0) daysElapsed = 1;
    if (totalDays <= 0) totalDays = 1;

    if (effectiveFilters.overallTarget > 0 && totalAdmissions > 0) {
      predictedAdmissions = Math.round((totalAdmissions / daysElapsed) * totalDays);
      if (predictedAdmissions < effectiveFilters.overallTarget * 0.9) { 
        onTrackWarning = true;
      }
    }
  }

  // --- Final KPI Calculations ---
  const kpis = {
    totalAdmissions: totalAdmissions,
    completionRate: totalAdmissions > 0 ? ((completedAdmissions / totalAdmissions) * 100).toFixed(1) + '%' : '0.0%',
    avgInternalMarks: internalMarksCount > 0 ? (totalInternalMarks / internalMarksCount).toFixed(2) : 'N/A',
    avgInternalScore: internalScoreCount > 0 ? (totalInternalScore / internalScoreCount).toFixed(2) : 'N/A',
    overallTarget: effectiveFilters.overallTarget,
    predictedAdmissions: predictedAdmissions,
    onTrackWarning: onTrackWarning
  };

  // --- Prepare Table Data ---
  const tableData = Array.from(centerAggregates.entries()).map(([code, data]) => {
    const centerTotal = data.totalLearners.size;
    const centerCompleted = data.completedLearners.size;
    const centerCompletionPct = centerTotal > 0 ? ((centerCompleted / centerTotal) * 100).toFixed(1) : '0.0';
    const centerAvgMarks = data.marksCount > 0 ? (data.totalMarks / data.marksCount).toFixed(2) : 'N/A';
    const centerAvgScore = data.scoreCount > 0 ? (data.totalScore / data.scoreCount).toFixed(2) : 'N/A';
    const genderMixArr = Array.from(data.genderMix.entries()).map(([g, count]) => `${g}: ${count}`);
    const paymentMixArr = Array.from(data.paymentMix.entries()).map(([p, count]) => `${p}: ${count}`);

    return {
      year: effectiveFilters.year,
      examEvent: effectiveFilters.examEvent,
      centerCode: code,
      centerName: data.centerName,
      actualAdmissions: centerTotal,
      completionPct: centerCompletionPct,
      avgInternalMarks: centerAvgMarks,
      avgInternalScore: centerAvgScore,
      genderMix: genderMixArr.join(', '),
      paymentStatusMix: paymentMixArr.join(', ')
    };
  }).sort((a,b) => b.actualAdmissions - a.actualAdmissions);

  // --- Prepare Chart Data ---
  const chartData = {};

  // Chart 1: Admissions Trend by Month (Multiple Years)
  let yearsToShowInTrendChart = new Set();
  const allUniqueYearsInData = new Set();
  Array.from(admissionsByMonthYearAllYears.keys()).forEach(key => {
    allUniqueYearsInData.add(key.substring(0, 4));
  });
  const sortedAllUniqueYears = Array.from(allUniqueYearsInData).sort();

  if (effectiveFilters.year === 'All') {
    if (sortedAllUniqueYears.length >= 2) {
      yearsToShowInTrendChart.add(sortedAllUniqueYears[sortedAllUniqueYears.length - 1]);
      yearsToShowInTrendChart.add(sortedAllUniqueYears[sortedAllUniqueYears.length - 2]);
    } else if (sortedAllUniqueYears.length === 1) {
      yearsToShowInTrendChart.add(sortedAllUniqueYears[0]);
    }
  } else {
    const selectedYear = parseInt(effectiveFilters.year);
    if (allUniqueYearsInData.has(String(selectedYear))) { yearsToShowInTrendChart.add(String(selectedYear)); }
    if (allUniqueYearsInData.has(String(selectedYear - 1))) { yearsToShowInTrendChart.add(String(selectedYear - 1)); }
  }

  const months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
  const monthCategories = months.map(m => new Date(2000, parseInt(m) - 1, 1).toLocaleString('en-us', { month: 'short' }));

  const admissionsTrendSeries = [];
  const sortedYearsForChart = Array.from(yearsToShowInTrendChart).sort();

  sortedYearsForChart.forEach(year => {
    const dataForYear = months.map(monthNum => {
      const monthYearKey = `${year}-${monthNum}`;
      return admissionsByMonthYearAllYears.has(monthYearKey) ? admissionsByMonthYearAllYears.get(monthYearKey).size : 0;
    });
    admissionsTrendSeries.push({ name: `Admissions ${year}`, data: dataForYear });
  });

  chartData.admissionsTrend = {
    series: admissionsTrendSeries,
    categories: monthCategories
  };

  // Chart 2: Admissions by RLC Region
  chartData.admissionsByRlcRegion = Array.from(rlcRegionAdmissionsMap.entries())
    .map(([region, learners]) => ({ x: region, y: learners.size }))
    .sort((a, b) => b.y - a.y);

  // Chart 3: Gender Distribution
  chartData.genderDistribution = Array.from(genderDistributionMap.entries())
    .map(([gender, learners]) => ({ x: gender, y: learners.size }))
    .sort((a, b) => b.y - a.y);

  // Chart 4: Admissions by Qualification
  chartData.admissionsByQualification = Array.from(qualificationAdmissionsMap.entries())
    .map(([qual, learners]) => ({ x: qual, y: learners.size }))
    .sort((a, b) => b.y - a.y);

  // Chart 5: Low-Completion Centers (from centerAggregates)
  chartData.lowCompletionCenters = Array.from(centerAggregates.entries())
    .map(([code, data]) => {
      const centerTotal = data.totalLearners.size;
      const centerCompleted = data.completedLearners.size;
      const completion = centerTotal > 0 ? parseFloat(((centerCompleted / centerTotal) * 100).toFixed(1)) : 0;
      return { x: data.centerName, y: completion };
    })
    .filter(item => item.y < 90 && item.y > 0)
    .sort((a, b) => a.y - b.y)
    .slice(0, 10);

  // New Chart: Exam Event Target Prediction
  const admissions2022 = examEventHistoricalData.has('2022') ? examEventHistoricalData.get('2022').size : 0;
  const admissions2023 = examEventHistoricalData.has('2023') ? examEventHistoricalData.get('2023').size : 0;
  const admissionsCurrentYear = examEventHistoricalData.has(effectiveFilters.year) ? examEventHistoricalData.get(effectiveFilters.year).size : 0;

  let suggestedTarget = 0;
  if (admissions2022 > 0 && admissions2023 > 0) {
    suggestedTarget = Math.round((admissions2022 + admissions2023) / 2);
  } else if (admissions2023 > 0) {
    suggestedTarget = admissions2023;
  }

  const manualTarget = effectiveFilters.manualTarget;
  let targetAlert = '';
  if (manualTarget > suggestedTarget * 1.2 && suggestedTarget > 0) {
    targetAlert = `Manual target of ${manualTarget} appears High-Risk based on historical trends. Suggested target is ${suggestedTarget}.`;
  } else if (manualTarget < suggestedTarget * 0.8 && suggestedTarget > 0) {
    targetAlert = `Manual target of ${manualTarget} appears Low-Ambition based on historical trends. Suggested target is ${suggestedTarget}.`;
  } else if (manualTarget > 0 && suggestedTarget === 0) {
     targetAlert = `No historical data for suggested target. Manual target set to ${manualTarget}.`;
  } else if (manualTarget === 0 && suggestedTarget > 0) {
     targetAlert = `Suggested target is ${suggestedTarget}. No manual target set.`;
  }

  // Determine the target to display (manual takes precedence)
  const displayedTarget = manualTarget > 0 ? manualTarget : suggestedTarget;

  chartData.examEventPrediction = {
    series: [
      { name: `Admissions 2022`, data: [admissions2022] },
      { name: `Admissions 2023`, data: [admissions2023] },
      { name: `Admissions ${effectiveFilters.year}`, data: [admissionsCurrentYear] }
    ],
    suggestedTarget: suggestedTarget,
    manualTarget: manualTarget,
    displayedTarget: displayedTarget, // New field to easily use for annotations
    targetAlert: targetAlert
  };

  // New Chart: Geographic & Demographic Admissions Heatmap
  const geoCategories = Array.from(heatmapAggregationMap.keys()).sort();
  const demoCategoriesSet = new Set(); 
  geoCategories.forEach(geoKey => {
    const demographicMap = heatmapAggregationMap.get(geoKey);
    demographicMap.forEach((learnerSet, demoKey) => { demoCategoriesSet.add(demoKey); });
  });
  const finalDemoCategories = Array.from(demoCategoriesSet).sort();

  const heatmapChartSeries = geoCategories.map(geoKey => {
      return {
          name: geoKey,
          data: finalDemoCategories.map(demoKey => {
              const demographicMap = heatmapAggregationMap.get(geoKey);
              const count = demographicMap && demographicMap.has(demoKey) ? demographicMap.get(demoKey).size : 0;
              return { x: demoKey, y: count };
          })
      };
  });

  chartData.admissionsHeatmap = {
    series: heatmapChartSeries,
    geoCategories: geoCategories,
    demoCategories: finalDemoCategories
  };

  // New Chart: ALC/LLC Performance & Demographics Bubble Chart
  chartData.alcLlcBubbleChart = Array.from(centerAggregates.entries()).map(([code, data]) => {
    const centerTotal = data.totalLearners.size;
    const centerCompleted = data.completedLearners.size;
    const completionRate = centerTotal > 0 ? parseFloat(((centerCompleted / centerTotal) * 100).toFixed(1)) : 0;
    const avgAge = data.ageCount > 0 ? parseFloat((data.totalAge / data.ageCount).toFixed(1)) : 0;
    const avgInternalScore = data.scoreCount > 0 ? parseFloat((data.totalScore / data.scoreCount).toFixed(1)) : 0;

    const bubbleSize = centerTotal; 

    return {
      name: data.centerName,
      data: [{
        x: avgInternalScore,
        y: completionRate,
        z: bubbleSize
      }]
    };
  }).filter(item => item.data[0].z > 0);


  // --- Generate Recommendations ---
  const recommendations = [];

  // 1. Overall Target Pacing
  if (kpis.onTrackWarning) {
      recommendations.push(`Warning: Current pace predicts ${kpis.predictedAdmissions} admissions by deadline, significantly below your overall target of ${kpis.overallTarget}. Consider immediate interventions.`);
  } else if (kpis.overallTarget > 0 && totalAdmissions > kpis.overallTarget) {
      recommendations.push(`Excellent: You have already surpassed your overall target of ${kpis.overallTarget} admissions!`);
  }

  // 2. Exam Event Prediction Alert
  if (chartData.examEventPrediction.targetAlert) {
    recommendations.push(`Target Strategy: ${chartData.examEventPrediction.targetAlert}`);
  }

  // 3. Low Completion Centers
  if (chartData.lowCompletionCenters && chartData.lowCompletionCenters.length > 0) {
    const lowestCenter = chartData.lowCompletionCenters[0];
    recommendations.push(
      `Action Needed: Address the low completion rate at ${lowestCenter.x} (${lowestCenter.y}% completion). Investigate training quality or learner support.`
    );
  }

  // 4. Districts with Low Admissions (example, using admissionsByLearnerDistrict map)
  const sortedDistricts = Array.from(admissionsByLearnerDistrict.entries())
    .map(([district, learners]) => ({ district, count: learners.size }))
    .sort((a, b) => a.count - b.count);

  if (sortedDistricts.length > 0 && sortedDistricts[0].count > 0 && sortedDistricts[0].count < totalAdmissions / sortedDistricts.length / 2) {
    recommendations.push(
      `Outreach Opportunity: Districts like ${sortedDistricts[0].district} show significantly lower admissions (${sortedDistricts[0].count}). Consider targeted marketing or community engagement.`
    );
  }

  // 5. High-Performing RLC Region (example)
  if (chartData.admissionsByRlcRegion && chartData.admissionsByRlcRegion.length > 0) {
      const topRlc = chartData.admissionsByRlcRegion[0];
      recommendations.push(`Best Practice: Study the strategies of ${topRlc.x} RLC Region, which leads with ${topRlc.y} admissions, for potential replication.`);
  }

  // Add a default if no specific recommendations were generated
  if (recommendations.length === 0) {
      recommendations.push("No specific action recommendations at this time based on current filters. All metrics appear to be within acceptable ranges or data is insufficient for advanced insights.");
  }


  // --- Final Return Statement ---
  return {
    kpis: kpis,
    tableData: tableData,
    chartData: chartData,
    recommendations: recommendations
  };

}
